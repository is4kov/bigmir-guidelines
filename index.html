<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Гайдлайны БЭМ @ bigmir)net</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link rel="stylesheet" href="style.css" />
</head>
<body>
<main class="l-wrapper">
    <header class="l-header">
        <h1 class="b-header">Гайдлайны БЭМ @ bigmir)net</h1>
    </header>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Предисловие</h2>
        </header>
        <article class="b-section__content">
            <p>На дворе было начало 2013-го года. Grunt в ту пору уже существовал, но не был особо известным, а до появления такой штуки, как CSS-постпроцессоры, еще оставался почти год.</p>
            <p>В это время мы всерьез занялись наведением порядка в нашем коде. Мы решили вычистить старый код и привести его к некоему однообразию, а также ввести несколько правил, согласно которым код в проекте писался бы в будущем.</p>
            <p>В проекте имелось огромное количество CSS-файлов, не имеющих общей структуры и архитектуры, которые подключались в шаблонах «по запросу» - если данный шаблон есть на странице, он тянул с собой свой CSS-файл, который подключался с помощью особой конструкции, на выходе превращающейся в обычный <code>&lt;link&gt;</code>, без сжатия и склеивания. В браузере это выглядело примерно так: около 20-30 отдельных небольших CSS-файлов на каждой странице. Это имело под собой некую логику - файлы кешировались (на 1 месяц) и загружались с сервера фактически только в первый раз. Менялись они тоже достаточно редко, тем не менее, это никак не могло оправдать такое большое количество запросов. Помимо этого, не было инструмента, позволяющего эффективно разрабатывать и поддерживать текущие объемы и поток задач.</p>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Внедрение и настройка LESS</h2>
        </header>
        <article class="b-section__content">
            <p>
                <figure right>
                    <img src="i/less.jpg" alt="" />
                    <figcaption>File watcher для компиляции LESS в CSS</figcaption>
                </figure>
            </p>
            <p>Основным IDE-редактором был выбран <a href="//jetbrains.com/phpstorm">PhpStorm</a> - он из коробки умел делать всё, что было необходимо для работы над проектом. Работу с препроцессором решено было также переложить на его плечи, используя для этого специальный инструмент под названием File watcher.</p>
            <p>Среди всех CSS-препроцессоров предпочтение было отдано LESS. Sass в то время не умел нормально склеивать CSS-селекторы в БЭМ-нотации (через служебную конструкцию '&'), а для Stylus в то время еще не было поддержки File watcher'ов.</p>
            <p>Окружение было таким – на машине верстальщика был установлен node.js и пакет less: <pre><code>npm install less -g</code></pre> В PhpStorm добавлялся File watcher для компиляции LESS в CSS.</p>
            <p>Позднее появилась возможность компилировать LESS в CSS прямо в браузере <em>в окружении разработчика</em> (при помощи get-параметра):</p>
            <pre><code>?debug=less</code></pre>
            <p>При внедрении LESS работа в первую очередь производилась в направлении объединения исходных CSS-файлов с целью уменьшения количества запросов, а также в создании гибкой, переносимой и масштабируемой архитектуры, чтобы собрать все общие стили и части интерфейса разных проектов в одну целую структуру.</p>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Архитектура LESS в проекте</h2>
        </header>
        <article class="b-section__content">
            <p>
                <figure left>
                    <img src="i/css-structure.jpg" alt="" />
                    <figcaption>Структура CSS проекта<br /><a href="//www.bigmir.net" target="_blank">главной страницы bigmir)net</a></figcaption>
                </figure>
            </p>
            <p>В первую очередь, были созданы два уровня абстракции для архитектуры LESS: <em>глобальный</em>, файлы откуда необходимы на любой странице любого проекта и подключаются всегда; и <em>локальный</em>, внутрипроектный уровень.</p>
            <p>Содержимое файлов более глобального уровня абстракции (переменные, примеси) всегда могут при необходимости быть переопределены в файлах более локального уровня. На самом деле, примеси в LESS <em>переопределить</em> нельзя (при создании дополнительного экземпляра примеси она просто выполнится при вызове, если будут соблюдены условия для ее вызова)</p>
            <p>Внутри проекта предполагалась следующая файловая структура: корневой .less-файл не содержал в себе ничего, кроме подключения глобальных и локальных констант и примесей, а также группы исходных файлов, содержащих стили для блоков, имеющихся в проекте. CSS перестал отдаваться точечно для каждого необходимого на странице блока, но стал отдаваться одним-двумя файлами.</p>
            <p>Файлы конфигурации (содержащие переменные, примеси, подключения шрифтов) находятся в папке <code>/inc/</code>. Файлы, содержащие наборы декларативных стилей, находятся в папке <code>/source/</code>. Позднее понадобилось также внести в архитектуру некоторых проектов папку <code>/plugins/</code> (она уже была в проекте, но содержала в себе только CSS-файлы, не имевшие отношения к LESS).</p>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Общие правила написания кода</h2>
        </header>
        <article class="b-section__content">
            <ul class="b-section-list">
                <li class="b-section-list-item">
                    <p>Разделение «блок-элемент» согласно дефолтным правилам БЭМ.</p>
                    <pre><code>.block__element</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Модификаторы могут иметь как элементы блоков, так и сами блоки.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Запись модификатора производится не в дефолтном виде, как <code>_key_value</code>, а просто <code>_something</code>, при этом больше опираясь на некое функциональное отличие этого модификатора от остальных, нежели на его визуальное содержание (второй вариант допустим лишь в крайнем случае).</p>
                    <pre><code>.block__element_modifier</code></pre>
                    <pre><code>.block_modifier</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Если какой-либо DOM-узел содержит в себе другие DOM-узлы – значит это блок. Элемент – некий конечный DOM-узел, не имеющий потомков (исключение – создание дополнительных внутренних или внешних контейнеров для различных декоративных целей).</p>
                </li>
                <li class="b-section-list-item">
                    <p>Использование каскада возможно в случае объявления модификатора на уровне корневого DOM-узла блока или на некоем уровне иерархии для задания контекста.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Контент из DB выводится без каких-либо дополнительных классов, определение стилей для элементов контента осуществляется через каскад и селекторы по тегам.</p>
                </li>
            </ul>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Пространство имен классов и префиксы</h2>
        </header>
        <p>Префиксы имен классов достались как legacy, потому было решено не отбрасывать их и использовать в дальнейшем по назначению, добавив несколько новых префиксов.</p>
        <article class="b-section__content">
            <ul class="b-section-list">
                <li class="b-section-list-item">
                    <p>Классы, отвечающие за общий скелет и раскладку страницы, имеют префикс <code>.l-</code> (<i>layout</i>)</p>
                    <pre><code>&lt;div class="<b>l-wrapper</b>"&gt;
    &lt;header class="<b>l-header</b>"&gt;...&lt;/header&gt;
    &lt;main class="<b>l-content</b>"&gt;...&lt;/main&gt;
    &lt;footer class="<b>l-footer</b>"&gt;...&lt;/footer&gt;
&lt;/div&gt;</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Глобальные классы, назначение и использование которых одинаково во всем проекте вне зависимости от его контекста, имеют префикс <code>.g-</code> (<i>global</i>)</p>
                    <pre><code>&lt;div class="<b>g-clearfix</b>"&gt;...&lt;/div&gt;</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Все остальные классы для обычного стилевого оформления элементов используют дефолтный префикс <code>.b-</code></p>
                </li>
                <li class="b-section-list-item">
                    <p>Классы, на которые опирается JS-часть в проекте (поиск элементов и работа с ними), имеют префикс <code>.js-</code></p>
                    <p>Все JS-хуки, необходимые на странице, вешаются на DOM-узлы только на классы с таким префиксом. Никаких декларативных свойств на такие классы не назначается.</p>
                    <pre><code>&lt;button class="b-header-login__trigger <b>js-login__trigger</b>"&gt;&lt;/button&gt;</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Классы, указывающие на измененное состояние DOM-узла в зависимости от каких-то внешних параметров или действий пользователя, имеют префикс <code>.is-</code></p>
                    <pre><code>&lt;li class="b-header-menu-list-item <b>is-active</b>"&gt;&lt;/li&gt;</code></pre>
                    <p>Это особенно удобно при работе в JS, где использование модификаторов неудобно, так как само название модификатора привязывается к конкретному классу и блоку, классы с префиксом <code>.is-</code> абсолютно независимы.</p>
                </li>
            </ul>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">Добавление нового компонента и навигация в коде проекта</h2>
        </header>
        <article class="b-section__content">
            <p>Обычно файл *.less создается с таким же именем, как и название компонента, стили для которого он описывает. Например, для компонента important-news необходимо будет создать файл important-news.less - это позволяет лучше ориентироваться в коде и легко понимать, в каком именно файле находятся нужные CSS-свойства.</p>
            <p>Потому практика использования слишком общих имен классов и названий компонентов отпадает сразу – название .news является слишком общим, и ни в коем случае не подходит для названия компонента.</p>
            <p>
                <figure left>
                    <img src="i/less+sourcemaps2.jpg" alt="" />
                    <figcaption>File watcher для генерации карт кода</figcaption>
                </figure>
            </p>
            <p>Если необходимо создать компонент, похожий на уже существующий, то во-первых, сначала проводится анализ, все ли стили и интерактивность (работающий JS в том числе) для этого компонента уже имеются в проекте. Если нужные стили уже имеются, оценивается, стоит ли создать модификатор для базового блока компонента, или же сделать его копию. Если конструкция не перенагружена модификаторами, и создание нового модификатора очевидно и возможно, основываясь на логическом назначении компонента, - создается новый модификатор, в противном случае создается новый компонент, имя которого с большей долей вероятности может быть основано на его внешнем виде.</p>
            <p>Позже была добавлена поддержка карт кода (source maps). Для этого был добавлен еще один file watcher, который вызывал компилятор LESS с нужными параметрами, не создавая при этом нового файла, и не перезаписывая таким образом файл, сгенерированный в результате работы первого file watcher'a.</p>
            <p>Файл карт кода .map создается с тем же именем, что и имя прообраза - .less-файла, и помещается в папку <code>/sourcemaps/</code>. Таким образом, всегда известно, по какому урлу находится .map-файл для каждого конкретного .css-файла.</p>
            <p>Функционал карт кода доступен по get-параметру <code>?soucremaps=1</code> в URL страницы. При этом URL файла карт кода дописывается в конец CSS-файла средствами сервера, во избежание лишних запросов к серверу (в Chrome, вне зависимости от установки флага "Enable Source Maps" в настройках Dev Tools, при наличии строки со ссылкой на файл карт кода выполнялся запрос к этому файлу).</p>
        </article>
    </section>
    <section class="b-section g-clearfix">
        <header class="b-section__header-outer">
            <h2 class="b-section__header">HTML</h2>
        </header>
        <article class="b-section__content">
            <p>HTML-код пишется в соответствии со спецификацией HTML5. Помимо этого, к нему предъявляется ряд требований:</p>
            <ul class="b-section-list">
                <li class="b-section-list-item">
                    <p>Использование семантических HTML5 тегов по назначению.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Отсутствие устаревших тегов или их атрибутов.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Имена тегов и атрибутов пишутся только в нижнем регистре.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Любой атрибут тега, кроме логических, записывается в виде <code>attr="value"</code>.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Для логических атрибутов достаточно лишь упоминания его названия внутри записи тега.</p>
                    <pre><code>&lt;input type="checkbox" value="..." <b>checked</b> /&gt;</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Одиночные теги закрываются согласно XML-правилам.</p>
                    <pre><code>&lt;img src="..." alt="" <b>/</b>&gt;</code></pre>
                </li>
            </ul>
        </article>
        <header class="b-section__header-outer">
            <h2 class="b-section__header">CSS</h2>
        </header>
        <article class="b-section__content">
            <ul class="b-section-list">
                <li class="b-section-list-item">
                    <p>CSS-селекторы</p>
                    <p>Использование CSS-селекторов по сущности, отличной от класса, крайне нежелательно. Исключение составляет контент, хранящийся в DB.</p>
                    <p>Использование каскада нежелательно и ограничено 3 (тремя) селекторами в каскаде. Из-за соображений производительности CSS и во избежание возникновения слишком многих контекстных зависимостей.</p>
                </li>
                <li class="b-section-list-item">
                    <p>При написании имен селекторов, а также названий CSS-правил и их значений, используются исключительно строчные буквы.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Название класса элемента не должно основываться на его декларативном представлении.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Не позволяется записывать несколько CSS-правил внутри блока на одной строке, то же самое касается перечисления нескольких CSS-селекторов внутри одного блока правил.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Разделение структурных частей CSS-правила пробелами: между названием правила и его значением, между селектором и открывающей скобкой.</p>
                </li>
                <li class="b-section-list-item">
                    <p>В конце каждого CSS-правила ставится точка с запятой.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Использование <code>!important</code> должно быть по максимуму сокращено, и не допускаться без крайней необходимости.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Использование CSS-хаков запрещено. Фиксы для старых версий IE делаются при помощи conditional comments.</p>
                    <p><small>HTML</small></p>
                    <pre><code>&lt;!--[if lt IE10]&gt;&lt;html class="lt-ie10              "&gt;&lt;![endif]--&gt;
&lt;!--[if lt IE 9]&gt;&lt;html class="lt-ie10 lt-ie9       "&gt;&lt;![endif]--&gt;
&lt;!--[if lt IE 8]&gt;&lt;html class="lt-ie10 lt-ie9 lt-ie8"&gt;&lt;![endif]--&gt;</code></pre>
                    <p><small>CSS</small></p>
                    <pre><code>.lt-ie8 .block { }</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Использование транслита и кириллицы в комментариях или в указаниях CSS-селекторов запрещено.</p>
                </li>
                <li class="b-section-list-item">
                    <p>Ноль - безразмерная величина, в указании единицы измерения при значении величины равным нулю нет необходимости.</p>
                    <pre><code>.block {
    margin: 10px 0;
    }</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>При записи значений CSS-свойств, выражаемых долями от единицы, запись должна начинаться сразу с точки, без указания нуля в начале.</p>
                    <pre><code>.block {
    opacity: .6;
    }</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>При возможности использовать сокращенный вариант записи цвета им следует пользоваться.</p>
                </li>
                <li class="b-section-list-item">
                    <p>При записи правил, поддерживающих несколько значений, каждое из этих значений стоит писать на отдельной строке, выравняв их по началу строки.</p>
                    <pre><code>.block {
    box-shadow: 0 5px 3px yellow,
                4px 0 -2px #999;
    }</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>При записи вендорных префиксов стоит указывать только актуальные префиксные свойства в порядке [ <code>-webkit-</code>, <code>-moz-</code>, <code>-ms-</code>, <code>-o-</code> ] (если нет необходимости использовать другой порядок для кроссбраузерной совместимости), после которых обязательно должно следовать правило без префикса.</p>
                    <p>Такие правила должны быть записаны каждое на отдельной строке, и выравнены по началу строки беспрефиксного правила.</p>
                    <pre><code>.block {
    -webkit-linear-gradient(top, #fff, red);
       -moz-linear-gradient(top, #fff, red);
         -o-linear-gradient(top, #fff, red);
            linear-gradient(to bottom, #fff, red);
    }</code></pre>
                </li>
                <li class="b-section-list-item">
                    <p>Использование абсолютных числовых значений CSS-свойств, смысл и значение которых непонятно или неочевидно, должно быть либо заменено на аналогичное значение, выраженное в относительной процентной величине, либо пояснено комментариями.</p>
                </li>
            </ul>
        </article>
    </section>
</main>
</body>
</html>